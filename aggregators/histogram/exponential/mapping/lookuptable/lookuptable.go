// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// LookupTableMapping is a prototype for OTEP 149.  The Go
// implementation was copied from one of the Java prototypes during
// review of
// https://github.com/open-telemetry/opentelemetry-proto/pull/322.
// See https://github.com/dynatrace-oss/dynahist/blob/9a6003fd0f661a9ef9dfcced0b428a01e303805e/src/main/java/com/dynatrace/dynahist/layout/OpenTelemetryExponentialBucketsLayout.java for the equations used here.
// The table of constants are generated by the program in ./generate.
package lookuptable

import (
	"math"

	"go.opentelemetry.io/contrib/aggregators/histogram/exponential/mapping"
)

type lookupTableMapping struct {
	// there are 2^scale buckets for the significand to map to.
	scale int32
	// An array of indices (lookup table). Significands of floats are mapped to this array
	// of equidistant buckets, which points to a bucket in the boundaries array
	// that is no further away than two buckets from the correct target bucket.
	indices []int64
	// the array of boundaries, represented as the significands of the double values in bits.
	boundaries []uint64
}

var _ mapping.Mapping = &lookupTableMapping{}

func NewMapping(scale int32) mapping.Mapping {
	if scale < 0 {
		// TODO: This logic does not work at negative scale
		// factors.  No calculated arrays are needed for
		// negative scales because the IEEE representation's
		// exponent maps directly to an index in that case.
		panic("unsupported scale")
	}

	bounds := calculateBoundaries(scale)
	indices := calculateIndices(bounds, scale)

	mapping := &lookupTableMapping{
		scale:      scale,
		indices:    indices,
		boundaries: bounds,
	}
	return mapping
}

// calculate boundaries for the significand part only.
// This calculates the bucket boundaries independent of the exponent.
// This mapping is the same for all significands, independent of the exponents.
// It depends only on the desired number of buckets subdividing the [1, 2] range covered by the significand.
// The number of buckets is 2^scale
func calculateBoundaries(scale int32) []uint64 {
	size := 1 << scale

	if len(exponentialConstants) < size {
		// See the code in ./printer to precompute larger constant arrays.
		panic("precomputed boundaries are not available")
	}

	// Note: boundaries is two longer than size to ensure the
	// `significand >= el.boundaries[i+1]` test below is correct.
	boundaries := make([]uint64, size+2)
	factor := len(exponentialConstants) / size

	for i := 0; i < size; i++ {
		boundaries[i] = exponentialConstants[i*factor]
	}

	boundaries[size] = 1 << mapping.SignificandWidth
	boundaries[size+1] = 1 << mapping.SignificandWidth

	return boundaries
}

// Create the array which is roughly mapping into the boundaries array
func calculateIndices(boundaries []uint64, scale int32) []int64 {
	length := 1 << scale
	indices := make([]int64, length)
	c := int64(0)
	for i := 0; i < length; i++ {
		// e.g. for scale = 2, this evaluates to:
		// i=0: 1.0; i=1: 1.25; i=2: 1.5; i=3: 1.75
		significandLowerBound := uint64(i) << (mapping.SignificandWidth - scale)
		// find the lowest boundary that is smaller than or equal to the equidistant bucket bound
		for boundaries[c+1] <= significandLowerBound {
			c++
		}
		indices[i] = c
	}
	return indices
}

// MapToIndex maps the double value to the correct bin.
func (lt *lookupTableMapping) MapToIndex(value float64) int64 {
	valueBits := math.Float64bits(value)

	// The last 52 bits (bits 0 through 51) of a double are the significand.
	// Get these from the valueBits, which is a bit representation of the double value
	significand := mapping.SignificandMask & valueBits

	// The bits 52 through 63 are the exponent.
	// extract the exponent from the bit representation of the double value.
	// Then shift it over by 52 bits (the length of the significand) and convert it to an integer
	// This also removes the sign bit.
	exponent := int64((mapping.ExponentMask & valueBits) >> mapping.SignificandWidth)
	exponent -= mapping.ExponentBias

	// find the "rough" bucket index from the indices array
	// The indices array has evenly spaced buckets and contains indices into the boundaries array
	// The line below transforms the normalized significand into an index into the indices array
	// Then, the index into the boundaries array is retrieved.
	rough := lt.indices[int(significand>>(mapping.SignificandWidth-lt.scale))]

	// The index in the boundaries array might not be correct
	// right away, there might be an offset of a maximum of two
	// buckets.  Therefore, look at three buckets: The one
	// specified by the index, and the next two.
	offset := rough
	if significand >= lt.boundaries[rough+1] {
		offset++
	}
	if significand >= lt.boundaries[rough+2] {
		offset++
	}

	// the indexOffset is only used to skip subnormal buckets
	// the exponent is used to find the correct "top-level" bucket,
	// and k is used to find the correct index therein.
	return (exponent << lt.scale) + offset
}

// LowerBoundary computes the inclusive lower bound corresponding to a
// particular histogram bucket.  This returns the least result value that
// such that `MapToIndex(lowerBoundary(index)) == index`.
func (lt *lookupTableMapping) LowerBoundary(index int64) (float64, error) {
	length := int64(1 << lt.scale)
	exponent := index / length
	position := index % length
	if position < 0 {
		position += length
		exponent -= 1
	}
	significand := lt.boundaries[position] & mapping.SignificandMask
	expo := uint64((int64(exponent+mapping.ExponentBias) << mapping.SignificandWidth))
	return math.Float64frombits(expo | significand), nil
}

func (lt *lookupTableMapping) Scale() int32 {
	return lt.scale
}
